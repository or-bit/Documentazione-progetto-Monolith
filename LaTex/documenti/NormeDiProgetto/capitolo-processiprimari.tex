\section{Processi primari}

\subsection{Fornitura}
\subsubsection{Studio di Fattibilità}
In seguito ad una discussione tra i componenti del gruppo sui capitolati proposti, è compito degli \Analisti{} redigere lo \textit{Studio di Fattibilità} di tali capitolati. Devono essere analizzati:
\begin{itemize}
	\item dominio tecnologico e applicativo: si valutano la conoscenza pregressa delle tecnologie richieste e del dominio applicativo;
	\item utenza: si valuta l'insieme di utenti a cui è rivolto il prodotto;
	\item rapporto costi/benefici: si valutano prodotti già esistenti, possibilità di affermazione nel mercato, costi di realizzazione e benefici del prodotto finito;
	\item rischi: si individuano i punti critici in cui la realizzazione potrebbe incorrere, a partire dalla conoscenza del dominio, fino alla verifica dei requisiti.
\end{itemize}
Deve essere quindi convocata una riunione interna per la decisione finale sul capitolato su cui svolgere il progetto.

\subsubsection{Consegna}
La consegna deve avvenire entro il giorno 27-06-2017, come da \PianoDiProgetto{}, previo appuntamento, presso la sede del \Committente{}. Il collaudo finale del prodotto si terrà durante la \RA{}.\\
Fanno parte del materiale da consegnare:
\begin{itemize}
	\item sorgente del framework e della demo;
	\item documentazione completa del prodotto.
\end{itemize}

\subsubsection{Completamento del progetto}
Con la consegna ed il collaudo effettuati nella \RA{}, il progetto è ritenuto concluso. Ulteriori modifiche saranno a carico dei singoli. Il gruppo Or-bit non si assume l'obbligo di mantenimento del codice sorgente, che rimarrà disponibile sul repository dedicato, in formato aperto.

\subsection{Sviluppo}

\subsubsection{Analisi dei Requisiti}
\paragraph{Ricerca dei requisiti}\mbox{}\\
Le funzionalità che caratterizzeranno il prodotto alla fornitura vengono concordate con gli \glossario{stakeholders} al momento della presentazione del capitolato d'appalto e attraverso il \glossario{gathering} di informazioni durante le riunioni. Viene fornita nel documento apposito \AnalisiDeiRequisiti{} la descrizione da parte del fornitore del suddetto prodotto.\\
Per assicurare una corretta e completa analisi deve essere stilato l'elenco dei casi d'uso.\\
Ogni caso d'uso deve essere descritto in modo formale seguendo le direttive presenti nel paragrafo \sezione{modellazione-casi-uso}.\\
I requisiti devono essere descritti fino al massimo livello di dettaglio nella Tabella dei Requisiti presente nel documento \AnalisiDeiRequisiti, includendo una descrizione delle fonti da cui derivano, siano esse interne o esterne.

\subparagraph{Modellazione dei casi d'uso}\mbox{}\label{modellazione-casi-uso}\\
Ogni caso d'uso deve essere descritto con:
\begin{itemize}
	\item titolo;
	\item attori;
	\item scopo e descrizione breve;
	\item precondizioni;
	\item flusso principale degli eventi, considerando eventuali distinzioni dei casi al suo interno;
	\item post-condizione.
\end{itemize}
Il caso d'uso deve essere accompagnato da un grafico riassuntivo in \glossario{UML} 2.5, titolato come il caso d'uso.\\
I casi d'uso devono essere catalogati secondo le seguenti norme:
\begin{center}
	UC[numero][caso]
\end{center}
dove:
\begin{itemize}
	\item \textit{UC} specifica che si sta parlando di un caso d'uso;
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al caso d'uso in questione;
	\item \textit{caso} individua eventuali diramazioni all'interno dello stesso caso d’uso.
\end{itemize}

\subparagraph{Classificazione dei requisiti}\mbox{}\\
I requisiti emersi dal capitolato devono essere catalogati secondo le seguenti norme:
\begin{center}
	R[utilità strategica][attributi di prodotto][numero]
\end{center}
dove:
\begin{itemize}
	\item \textit{R} specifica che si sta parlando di un requisito;
	\item \textit{utilità strategica} assume uno dei seguenti valori:
	\begin{enumerate}
		\item se il requisito è obbligatorio;
		\item se il requisito è desiderabile;
		\item se il requisito è opzionale.
	\end{enumerate}
	\item \textit{attributi di prodotto} assume uno dei seguenti valori:
	\begin{itemize}
		\item [F] se il requisito è funzionale;
		\item [P] se il requisito è prestazionale;
		\item [Q] se il requisito è di qualità;
		\item [V] se il requisito è di vincolo.
	\end{itemize}
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al requisito in questione.
\end{itemize}

\paragraph{Tracciamento}\mbox{}\\
\`{E} compito degli \Analisti{} controllare la corrispondenza tra i requisiti e le loro fonti (capitolato, casi d'uso, verbali di riunioni). Questa corrispondenza deve essere presentata nelle due tabelle di tracciamento Fonti-Requisiti e Requisiti-Fonti per facilitarne la consultazione. 

\subsubsection{Progettazione}\label{Progettazione}
Scopo delle attività di progettazione è la traduzione dei requisiti individuati durante l'analisi in una architettura software, soluzione del problema, unione dei sottosistemi che rappresentano le funzionalità.
È quindi compito dei \Progettisti{} costruire una architettura logica del prodotto, che sia efficace ed efficiente, ovvero che funzioni, soddisfi i requisiti e lo faccia nel miglior modo possibile, riducendo il consumo di risorse allo stretto necessario. È altresì compito dei \Progettisti{} suddividere il sistema in componenti semplici, implementabili da singoli individui, così da guidare il lavoro dei \Programmatori{} durante i periodi di \Cod{}.\\
Al fine di garantire la qualità, il prodotto della progettazione dovrà avere le seguenti caratteristiche:
\begin{itemize}
	\item sufficienza;
	\item comprensibilità;
	\item modularità;
	\item robustezza;
	\item flessibilità;
	\item riusabilità;
	\item efficienza;
	\item affidabilità;
	\item disponibilità;
	\item sicurezza rispetto a malfunzionamenti;
	\item sicurezza rispetto a intrusioni;
	\item semplicità;
	\item incapsulazione;
	\item coesione;
	\item basso accoppiamento.
\end{itemize}

\paragraph{Progettazione architetturale}\mbox{}\\
\`{E} compito dei \Progettisti{} eseguire la \PA{} ad alto livello del prodotto. È altresì compito loro descriverla nella \SpecificaTecnica.\\
Vanno perseguiti i seguenti obiettivi:
\begin{itemize}
	\item soddisfare i requisiti con un sistema di qualità;
	\item impiegare componenti con specifica chiara e coesa, realizzabili con le risorse e i costi fissati;
	\item realizzare una struttura che faciliti eventuali cambiamenti futuri;
	\item identificare schemi architetturali utili al caso e componenti riusabili, sfruttando i design pattern.
\end{itemize}

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere realizzati i seguenti diagrammi:
\begin{itemize}
	\item diagrammi dei \glossario{package};
	\item diagrammi delle classi;
	\item diagrammi di sequenza;
	\item diagrammi di attività.
\end{itemize}

\subparagraph{Design pattern}\mbox{}\\
Devono essere descritti i \glossario{design pattern} utilizzati specificando:
\begin{itemize}
	\item scopo del design pattern;
	\item funzionamento del design pattern;
	\item diagramma delle classi generico del design pattern.
\end{itemize}

\subparagraph{Tracciamento componenti}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e componenti che li soddisfano.

\paragraph{Progettazione di dettaglio}\mbox{}\\
\`{E} compito dei \Progettisti{} effettuare la \PD{} del prodotto, dettagliando quanto progettato ad alto livello e descritto nella \SpecificaTecnica{}. È altresì loro compito riportare quanto risultante nella \DefinizioneDiProdotto{}.\\
Vanno perseguiti i seguenti obiettivi:
\begin{itemize}
	\item dominare la complessità del sistema, suddividendolo in componenti con complessità trattabile e implementabili dai singoli;
	\item riconoscere le componenti terminali;
	\item mantenere un compromesso tra complessità delle unità e dell'integrazione di queste tra loro.
\end{itemize}

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere realizzati i seguenti diagrammi:
\begin{itemize}
	\item Diagrammi delle classi;
	\item Diagrammi di sequenza.
\end{itemize}

\subparagraph{Definizione di classe}\mbox{}\\
Ogni classe progettata deve seguire lo standard UML 2.5 e deve avere le seguenti proprietà, accompagnate nella \DefinizioneDiProdotto{} da una descrizione chiarificante:
\begin{itemize}
	\item \textbf{attributi}: vanno indicati l'accessibilità e il nome;
	\item \textbf{metodi}: vanno indicati l'accessibilità e il nome;
	\item \textbf{parametri}: vanno racchiusi tra parentesi tonde e devono essere riportati con nome e tipo, separati da due punti.
\end{itemize}
Ogni classe deve inoltre essere accompagnata da una descrizione che ne includa lo scopo e le funzionalità.

\subparagraph{Tracciamento delle classi}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e classi che li soddisfano.

\paragraph{Metriche per la progettazione}\mbox{}\\
Si concentrano sulle caratteristiche dell'architettura ad alto livello. Si basano sull'analisi di modelli di progetto nei quali sono evidenziati i moduli di sistema e i dati scambiati.

\subparagraph{Accoppiamento}\mbox{}\\
L'accoppiamento determina il numero di collaborazioni tra classi, ovvero il numero di altre classi cui una classe è accoppiata.\\
L'accoppiamento può avvenire a seguito di lettura o modifica di attributi, chiamata di metodi o istanziazione di oggetti. Un uso eccessivo è negativo per la modularità ed il riuso: più una classe è indipendente più è riutilizzabile. L'accoppiamento influisce anche sull'impatto delle modifiche in altri moduli: valori elevati di accoppiamento complicano le attività di testing e le modifiche.
\[ U = M \cdot N \]
$M$ componenti in accoppiamento con $N$ altri componenti producono un grado di interdipendenza $U$.
\textit{Fan-In} denomina quante classi utilizzano la classe presa in esame durante la loro esecuzione, Fan-In determina la dipendenza dal resto del codice prodotto. 
\textit{Fan-Out} denomina quante classi vengono utilizzate dalla classe presa in esame durante la sua esecuzione, alti livelli di Fan-Out determinano alti livelli di accoppiamento rendendo il codice complesso da testare, livelli bassi di Fan-Out corrispondono a codice più facilmente riusabile per altri scopi dato che è indipendente totalmente o quasi dal resto del progetto.

\subparagraph{Complessità ciclomatica}\mbox{}\\
Questa tecnica utilizza elementi della teoria dei grafi per schematizzare il flusso di controllo del programma. Rappresenta gruppi di istruzioni in nodi e le interazioni fra loro in archi: i nodi corrispondono ai gruppi di istruzioni, mentre gli archi connettono gruppi di istruzioni che possono essere eseguite sequenzialmente.\\
Dato un grafo $G$ di $n$ nodi ed $e$ archi, la complessità ciclomatica è data da:
\[ V\left(G\right) = e - n + 2 \]
Valori alti di complessità indicano poca manutenibilità del codice e maggiore quantità di test per la verifica, ma valori bassi possono indicare poca efficienza.

\subsubsection{Codifica}\label{Codifica}
Lo scopo del processo di codifica è quello di implementare il codice in conformità con la progettazione svolta. Parte fondamentale di questo processo è anche la stesura di un'adeguata documentazione del codice sviluppato. Tutti i file contenenti codice o documentazione prodotti da questo processo dovranno essere conformi alla codifica \glossario{UTF-8}.

\paragraph{Convenzioni} \label{sec:convenzioni}\mbox{}\\
Al fine di ottimizzare il passaggio tra progettazione e prodotto finale, i \Programmatori{} sono tenuti a rispettare le convenzioni che seguono.\\
Si è deciso di seguire le linee guida specificate nel capitolato e concordate con il proponente:
\begin{itemize}
	\item \glossario{Airbnb JavaScript style guide}\footnote{\url{https://github.com/airbnb/javascript}};
	\item \glossario{12 Factors app}\footnote{\url{https://12factor.net/}} documentandone l'utilizzo;
	\item limitare i commenti alle sole parti di codice che richiedano una spiegazione immediata del loro funzionamento;
	\item evitare le \glossario{callback}, o motivarne opportunamente l’uso;
\end{itemize}

\paragraph{Nomi}\label{sec:nomi}\mbox{}\\
I nomi di variabili, metodi e classi devono essere scritti in lingua inglese. I nomi delle classi devono iniziare con una lettera maiuscola, mentre quelli dei metodi con una lettera minuscola. Tutte le classi, metodi e variabili devono avere dei nomi significativi che aiutino a comprendere la loro funzione al fine di rendere il codice più facilmente comprensibile ad una lettura diretta. Bisogna inoltre evitare di utilizzare più volte lo stesso nome per diversi elementi, anche se facenti parte di pezzi diversi del progetto, al fine di ridurre al minimo la possibile confuzione.

\paragraph{Documentazione}\label{sec:documentazione}\mbox{}\\
Tutto il codice prodotto deve venire appropriatamente documentato. La documentazione va scritta in inglese e deve risultare sufficiente a comprendere le funzionalità di ciascun componente del progetto. In particolare ogni classe ed ogni metodo dovranno essere correlati da una breve ma completa descrizione delle loro funzionalità. Qualora durante il processo di codifica vengano identificate sezioni di codice particolarmente complicate o non chiare queste devono essere documentate in maniera più approfondia. I commenti devono sempre precedere le parti di codice a cui si riferiscono e devono essere scritti in modo da risultare facilmente comprensibili.

\paragraph{Ricorsione}\mbox{}\\
La ricorsione deve essere evitata quando possibile, onde evitare un elevato consumo di memoria a discapito delle performance del prodotto finale.

\paragraph{Metriche per la codifica}\mbox{}
\subparagraph{Numero di parametri per funzione}\mbox{}\\
Indica il numero di parametri passati ad un metodo; un valore molto alto potrebbe indicare eccessiva complessità e una suddivisione non efficace in sotto-metodi.

\subparagraph{Metriche di Halstead}\mbox{}\\
Misurano l'implementazione del programma in base al codice sorgente considerato come un algoritmo, quindi come un insieme di operatori e operandi.\\
Vengono così contrassegnati i componenti del codice:
\begin{itemize}
	\item $\eta_{1}$ = numero di operatori distinti;
	\item $\eta_{2}$ = numero di operandi distinti;
	\item $N1$ = numero totale di occorrenze degli operatori; 
	\item $N2$ = numero totale di occorrenze degli operandi;
\end{itemize}
Secondo questa marcatura possiamo calcolare:
\begin{itemize}
	\item il vocabolario del programma:
	\[ \eta = \eta_{1} + \eta_{2} \]
	\item la lunghezza del programma:
	\[ N = N1 + N2 \]
	\item la lunghezza calcolata del programma: 
	\[ {\hat {N}}=\eta_{1} \cdot \log_{2}\eta_{1}+\eta_{2} \cdot \log_{2}\eta_{2} \]
	\item il volume del programma:
	\[ V = N \cdot \log_{2}\eta \] 
	dove
	\begin{itemize}
		\item $ \log_{2}\eta $ è il numero di bit necessari per rappresentare il vocabolario;
		\item $ V $ è il numero di bit necessari per rappresentare il programma nella sua forma minima.\footnote{Il concetto di volume è legato quindi al contenuto di informazione del programma e dovrebbe dipendere unicamente dall'algoritmo scelto, non dall'espressività del linguaggio di programmazione.}
	\end{itemize}
	\item la difficoltà di scrittura e comprensione del programma:
	\[ D = \frac{\eta_{1}}{2} \cdot \frac{N_{2}}{\eta_{2}} \]
	\item lo sforzo complessivo sostenuto nella scrittura del programma:
	\[ E = D \cdot V \]
	\item il tempo di scrittura del programma:
	\[ T=\frac{E}{18}\ secondi\]
	\item il numero di bug in proporzione allo sforzo richiesto:
	\[ B = \frac{E^{\frac{2}{3}}}{3000} \]	
\end{itemize}

\subparagraph{Core size}\mbox{}\\
I core file sono file altamente interconnessi da una catena di dipendenze cicliche, i quali sono maggiormente propensi ad avere difetti. Core size è la percentuale di file con una o più dipendenze che hanno un alto fan-in ed un alto fan-out. Il calcolo di questa metrica viene effettuato attraverso strumenti automatici.

\subparagraph{Indice di manutenibilità}\mbox{}\\
Misura l’attitudine di una entità in assegnate condizioni di utilizzazione a essere mantenuta o riportata in uno stato nel quale può svolgere la funzione richiesta, quando la manutenzione è eseguita nelle condizioni date, con procedure e mezzi prescritti. Viene calcolato attraverso strumenti automatici.

