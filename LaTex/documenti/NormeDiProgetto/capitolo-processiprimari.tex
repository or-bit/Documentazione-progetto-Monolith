\section{Processi primari}

\subsection{Fornitura}
\subsubsection{Studio di Fattibilità}
In seguito ad una discussione tra i componenti del gruppo sui capitolati proposti, è compito degli \Analisti{} redigere lo \textit{Studio di Fattibilità} di tali capitolati. Devono essere analizzati:
\begin{itemize}
	\item dominio tecnologico e applicativo: si valutano la conoscenza pregressa delle tecnologie richieste e del dominio applicativo;
	\item utenza: si valuta l'insieme di utenti a cui è rivolto il prodotto;
	\item rapporto costi/benefici: si valutano prodotti già esistenti, possibilità di affermazione nel mercato, costi di realizzazione e benefici del prodotto finito;
	\item rischi: si individuano i punti critici in cui la realizzazione potrebbe incorrere, a partire dalla conoscenza del dominio, fino alla verifica dei requisiti.
\end{itemize}
Deve essere quindi convocata una riunione interna per la decisione finale sul capitolato su cui svolgere il progetto.

\subsection{Sviluppo}

\subsubsection{Analisi dei Requisiti}
\paragraph{Ricerca dei requisiti}\mbox{}\\
Le funzionalità che caratterizzeranno il prodotto alla fornitura vengono concordate con gli \glossario{stakeholders} al momento della presentazione del capitolato d'appalto e attraverso il \glossario{gathering} di informazioni durante le riunioni. Viene fornita nel documento apposito \AnalisiDeiRequisiti{} la descrizione da parte del fornitore del suddetto prodotto.\\
Per assicurare una corretta e completa analisi deve essere stilato l'elenco dei casi d'uso.\\
Ogni caso d'uso deve essere descritto in modo formale seguendo le direttive presenti nel paragrafo \sezione{modellazione-casi-uso}.\\
I requisiti devono essere descritti fino al massimo livello di dettaglio nella Tabella dei Requisiti presente nel documento \AnalisiDeiRequisiti, includendo una descrizione delle fonti da cui derivano, siano esse interne o esterne.

\subparagraph{Modellazione dei casi d'uso}\mbox{}\label{modellazione-casi-uso}\\
Ogni caso d'uso deve essere descritto con:
\begin{itemize}
	\item titolo;
	\item attori;
	\item scopo e descrizione breve;
	\item precondizioni;
	\item flusso principale degli eventi, considerando eventuali distinzioni dei casi al suo interno;
	\item post-condizione.
\end{itemize}
Il caso d'uso deve essere accompagnato da un grafico riassuntivo in \glossario{UML} 2.5, titolato come il caso d'uso.\\
I casi d'uso devono essere catalogati secondo le seguenti norme:
\begin{center}
	UC[numero][caso]
\end{center}
dove:
\begin{itemize}
	\item \textit{UC} specifica che si sta parlando di un caso d'uso;
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al caso d'uso in questione;
	\item \textit{caso} individua eventuali diramazioni all'interno dello stesso caso d’uso.
\end{itemize}

\subparagraph{Classificazione dei requisiti}\mbox{}\\
I requisiti emersi dal capitolato devono essere catalogati secondo le seguenti norme:
\begin{center}
	R[utilità strategica][attributi di prodotto][numero]
\end{center}
dove:
\begin{itemize}
	\item \textit{R} specifica che si sta parlando di un requisito;
	\item \textit{utilità strategica} assume uno dei seguenti valori:
	\begin{enumerate}
		\item se il requisito è obbligatorio;
		\item se il requisito è desiderabile;
		\item se il requisito è opzionale.
	\end{enumerate}
	\item \textit{attributi di prodotto} assume uno dei seguenti valori:
	\begin{itemize}
		\item [F] se il requisito è funzionale;
		\item [P] se il requisito è prestazionale;
		\item [Q] se il requisito è di qualità;
		\item [V] se il requisito è di vincolo.
	\end{itemize}
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al requisito in questione.
\end{itemize}

\paragraph{Tracciamento}\mbox{}\\
\`{E} compito degli \Analisti{} controllare la corrispondenza tra i requisiti e le loro fonti (capitolato, casi d'uso, verbali di riunioni). Questa corrispondenza deve essere presentata nelle due tabelle di tracciamento Fonti-Requisiti e Requisiti-Fonti per facilitarne la consultazione. 

\subsubsection{Progettazione}
\paragraph{Specifica Tecnica}\mbox{}\\
\`{E} compito dei \Progettisti{} descrivere la \PA{} ad alto livello del prodotto nella \SpecificaTecnica.

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere realizzati i seguenti diagrammi:
\begin{itemize}
	\item diagrammi dei \glossario{package};
	\item diagrammi delle classi;
	\item diagrammi di sequenza;
	\item diagrammi di attività.
\end{itemize}

\subparagraph{Design pattern}\mbox{}\\
Devono essere descritti i \glossario{design pattern} utilizzati specificando:
\begin{itemize}
	\item scopo del design pattern;
	\item funzionamento del design pattern;
	\item diagramma delle classi generico del design pattern.
\end{itemize}

\subparagraph{Tracciamento Componenti}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e componenti che li soddisfano.

\paragraph{Definizione di Prodotto}\mbox{}\\
\`{E} compito dei \Progettisti{} stilare la \DefinizioneDiProdotto, in cui è descritta la \PD{} del prodotto, ampliando quanto detto nella \SpecificaTecnica.

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere aggiornati i seguenti diagrammi:
\begin{itemize}
	\item Diagrammi delle classi;
	\item Diagrammi di sequenza;
	\item Diagrammi di attività.
\end{itemize}

\subparagraph{Definizione di Classe}\mbox{}\\
Nella \DefinizioneDiProdotto{} deve essere descritta ogni classe progettata, secondo lo standard UML 2.5. La descrizione deve essere costituita da:
\begin{itemize}
	\item \textbf{attributi}: vanno indicati l'accessibilità, il nome e la descrizione di ognuno;
	\item \textbf{metodi}: vanno indicati l'accessibilità, il nome e la descrizione di ognuno;
	\item \textbf{parametri}: vanno racchiusi tra parentesi tonde e devono essere riportati con nome e tipo, separati da due punti;
	\item \textbf{argomenti}: vanno indicati la direzione tra parentesi quadre, nome e tipo separati da due punti, seguiti da una breve descrizione.
\end{itemize}
Ogni classe deve inoltre essere accompagnata da una descrizione che ne includa lo scopo e le funzionalità.

\subparagraph{Tracciamento delle Classi}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e classi che li soddisfano.

\subparagraph{Test}\mbox{}\\
\`{E} compito dei \Progettisti{} configurare in modo adeguato i test di unità e di integrazione, tramite \glossario{driver}, \glossario{stub} ed altri eventuali strumenti.\\
\`{E} responsabilità del \Programmatore{} attuare i test di unità più semplici, mentre i restanti devono essere eseguiti tramite strumenti automatici.\\
I test di integrazione devono essere eseguiti tramite strumenti automatici quando possibile. \`{E} compito dei \Verificatori{} verificarne l'integrità.\\
Devono essere eseguiti inoltre test di regressione in caso di modifiche, per accertare che queste non causino errori nelle parti già sottoposte a verifica con esito positivo. In questo modo viene garantito che le modifiche effettuate non pregiudichino le funzionalità esistenti e già testate.

\paragraph{Metriche per la progettazione}\mbox{}\\
Si concentrano sulle caratteristiche dell'architettura ad alto livello. Si basano sull'analisi di modelli di progetto nei quali sono evidenziati i moduli di sistema e i dati scambiati.

\subparagraph{Accoppiamento}\mbox{}\\
L'accoppiamento determina il numero di collaborazioni tra classi, ovvero il numero di altre classi cui una classe è accoppiata.\\
L'accoppiamento può avvenire a seguito di lettura o modifica di attributi, chiamata di metodi o istanziazione di oggetti. Un uso eccessivo è negativo per la modularità ed il riuso: più una classe è indipendente più è riutilizzabile. L'accoppiamento influisce anche sull'impatto delle modifiche in altri moduli: valori elevati di accoppiamento complicano le attività di testing e le modifiche.
\[ U = M \cdot N \]
$M$ componenti in accoppiamento con $N$ altri componenti producono un grado di interdipendenza $U$.
\textit{Fan-In} denomina quante classi utilizzano la classe presa in esame durante la loro esecuzione, Fan-In determina la dipendenza dal resto del codice prodotto. 
\textit{Fan-Out} denomina quante classi vengono utilizzate dalla classe presa in esame durante la sua esecuzione, alti livelli di Fan-Out determinano alti livelli di accoppiamento rendendo il codice complesso da testare, livelli bassi di Fan-Out corrispondono a codice più facilmente riusabile per altri scopi dato che è indipendente totalmente o quasi dal resto del progetto.

\subparagraph{Complessità ciclomatica}\mbox{}\\
Questa tecnica utilizza elementi della teoria dei grafi per schematizzare il flusso di controllo del programma. Rappresenta gruppi di istruzioni in nodi e le interazioni fra loro in archi: i nodi corrispondono ai gruppi di istruzioni, mentre gli archi connettono gruppi di istruzioni che possono essere eseguite sequenzialmente.\\
Dato un grafo $G$ di $n$ nodi ed $e$ archi, la complessità ciclomatica è data da:
\[ V\left(G\right) = e - n + 2 \]
Valori alti di complessità indicano poca manutenibilità del codice e maggiore quantità di test per la verifica, ma valori bassi possono indicare poca efficienza.

\subsubsection{Codifica}
Tutti i file contenenti codice o documentazione dovranno essere conformi alla codifica \glossario{UTF-8}.

\paragraph{Convenzioni} \label{sec:convenzioni}\mbox{}\\
Al fine di ottimizzare il passaggio tra progettazione e prodotto finale, i \Programmatori{} sono tenuti a rispettare le convenzioni che seguono.\\
Si è deciso di seguire le linee guida specificate nel capitolato e concordate con il proponente:
\begin{itemize}
	\item \glossario{Airbnb JavaScript style guide}\footnote{\url{https://github.com/airbnb/javascript}};
	\item \glossario{12 Factors app}\footnote{\url{https://12factor.net/}} documentandone l'utilizzo;
	\item limitare i commenti alle sole parti di codice che richiedano una spiegazione immediata del loro funzionamento;
	\item evitare le \glossario{callback}, o motivarne opportunamente l’uso.
\end{itemize}
\paragraph{Ricorsione}\mbox{}\\
La ricorsione deve essere evitata quando possibile, onde evitare un elevato consumo di memoria a discapito delle performance del prodotto finale.

\paragraph{Metriche per la codifica}\mbox{}
\subparagraph{Numero di parametri per funzione}\mbox{}\\
Indica il numero di parametri passati ad un metodo; un valore molto alto potrebbe indicare eccessiva complessità e una suddivisione non efficace in sotto-metodi.

\subparagraph{Metriche di Halstead}\mbox{}\\
Misurano l'implementazione del programma in base al codice sorgente considerato come un algoritmo, quindi come un insieme di operatori e operandi.\\
Vengono così contrassegnati i componenti del codice:
\begin{itemize}
	\item $\eta_{1}$ = numero di operatori distinti;
	\item $\eta_{2}$ = numero di operandi distinti;
	\item $N1$ = numero totale di occorrenze degli operatori; 
	\item $N2$ = numero totale di occorrenze degli operandi;
\end{itemize}
Secondo questa marcatura possiamo calcolare:
\begin{itemize}
	\item il vocabolario del programma:
	\[ \eta = \eta_{1} + \eta_{2} \]
	\item la lunghezza del programma:
	\[ N = N1 + N2 \]
	\item la lunghezza calcolata del programma: 
	\[ {\hat {N}}=\eta_{1} \cdot \log_{2}\eta_{1}+\eta_{2} \cdot \log_{2}\eta_{2} \]
	\item il volume del programma:
	\[ V = N \cdot \log_{2}\eta \] 
	dove
	\begin{itemize}
		\item $ \log_{2}\eta $ è il numero di bit necessari per rappresentare il vocabolario;
		\item $ V $ è il numero di bit necessari per rappresentare il programma nella sua forma minima.\footnote{Il concetto di volume è legato quindi al contenuto di informazione del programma e dovrebbe dipendere unicamente dall'algoritmo scelto, non dall'espressività del linguaggio di programmazione.}
	\end{itemize}
	\item la difficoltà di scrittura e comprensione del programma:
	\[ D = \frac{\eta_{1}}{2} \cdot \frac{N_{2}}{\eta_{2}} \]
	\item lo sforzo complessivo sostenuto nella scrittura del programma:
	\[ E = D \cdot V \]
	\item il tempo di scrittura del programma:
	\[ T=\frac{E}{18}\ secondi\]
	\item il numero di bug in proporzione allo sforzo richiesto:
	\[ B = \frac{E^{\frac{2}{3}}}{3000} \]	
\end{itemize}

\subparagraph{Core size}\mbox{}\\
I core file sono file altamente interconnessi da una catena di dipendenze cicliche, i quali sono maggiormente propensi ad avere difetti. Core size è la percentuale di file con una o più dipendenze che hanno un alto fan-in ed un alto fan-out. Il calcolo di questa metrica viene effettuato attraverso strumenti automatici.

\subparagraph{Indice di manutenibilità}\mbox{}\\
Misura l’attitudine di una entità in assegnate condizioni di utilizzazione a essere mantenuta o riportata in uno stato nel quale può svolgere la funzione richiesta, quando la manutenzione è eseguita nelle condizioni date, con procedure e mezzi prescritti. Viene calcolato attraverso strumenti automatici.

